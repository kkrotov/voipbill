Главный скрит тестирования: run_comparative_tests.sh из него запускаются
отсальные скрипты 

Краткие описания некоторых файлов:

create_schema.sh : загружает схемы с настоящих БД на локальную
fill_data.sh : загружает данные с настоящих БД на локальную
sampler.py : генерирует тестовые звонки
regions-list : списки регионов, которые будут запускаться и тестироваться
make_configs.py : создает конфиги для биллера
    основываясь на regions-list
stop.sh : останавливает биллеры
compile.sh : компилирует биллер
switch_repo_to_tested.sh : сохраняет текущую ветку, как new
    делает git checkout на ветку released:released.
swith_repo_back.sh : делает git checkout изначальной(new) ветки
run.sh : запускает биллеры

В папке:
1) unit хранятся юнит тесты
2) functional хранятся функциональные тесты
3) comparative сравнительные тесты

Unit - тестирование
Используется cxxtest

unit - тесты состоят из .h файлов с классами отнаследованными
 от CxxTest::TestSuite. Как пример можно посмотреть unit/RemoveHtmlTagsTest.h

В папке mock хранятся заглушки нужные для юнит тестирования.

С помошью CMakeLists.txt генерируется единый unit/utest бинарник
 со всеми unit тестами. Он запускается из unit/start.sh

Как добавить юнит - тест?
1) Написать .h файл и поместить его в unit/newTest.h, как пример можно
 посмотреть unit/RemoveHtmlTagsTest.h и доки по cxxtest
2) Если тесту нужны заглушки добавить их в unit/mock/src-bill, и указать
 в CMakeLists.txt в переменной TESTING_SOURCES
3) Добавить в CMakeLists.txt в CXXTEST_ADD_TEST юнит тестирования название
 нового теста

Как пользоваться юнит тестами?
1) Скомпилировать их. Тк они добавлены в CMakeLists.txt то их компиляция
 будет произведена при make
2) После компиляции появится tests/unit/utest. Этот бинарник производит тесты.
 что бы запустить не все тесты сразу, а только один, то нужно указать его
 в качестве аргумента (пр: ./utest RemoveHtmlTagsTest )

Functional тестирование
функциональное тестирование использует cxxtest

functional тесты состоят из .h файлов с классами относледованными от
 CxxTest::TestSuite. Как пример можно посмотреть
 functional/NNPNumberRangeFindTest

С помощью CMakeLists.txt генерируется единый functional/ftest бинарник
 со всеми functional тестами. Он запускается из functional/start.sh

В папке functional присутствуют файлы облегчающие написание тестов.
common.h
common.cpp : Общий для тестов часто нужный функционал

BaseTest.h
BaseTest.cpp : Класс тестов с Curl, БД, ошибками

ComparisonTest.h
ComparisonTest.cpp : Класс сравнительных тестов, работающиз по принципу
 сравнения результатов полученных надеждным путем и через тестируемый
 функционал биллера.

Как добавить functional - тест?
1) Написать .h файл и поместить его в functional/newTest.h, как пример можно
 посмотреть unit/RemoveHtmlTagsTest.h и доки по cxxtest
2) Если тесту нужны заглушки добавить их в functional/mock/src-bill, и указать
 в CMakeLists.txt в переменной TESTING_SOURCES
3) Добавить в CMakeLists.txt в CXXTEST_ADD_TEST functional тестирования название
 нового теста

Как добавить новый functional - тест, используя ComparisonTest ?
1) В .h файл подключить "ComparisonTest.h"
2) При создании класса тестирования относледовать его от
 public CxxTest::TestSuite, public ComparisonTest
3) Переопределить функции

setResult - должна вычислять результат через тестируемый
 функционал и записывать его 
checkResult - должна надежно вычислять результат
 и сравниваеть его с тем, что было вычислен через тестируемый
 функционал.
getResultsNumber - количество результатов (количество проводимых сравнений)

при возникновении ошибки записывать её в lastError

добавить метод

void testThis () { TS_ASSERT (this->testAllResults()); }

Как пользоваться functional - тестами ?

1) Скомпилировать их. Тк они добавлены в CMakeLists.txt то их компиляция
 будет произведена при make
2) После компиляции появится tests/functional/ftest. Этот бинарник производит тесты.
 что бы запустить не все тесты сразу, а только один, нужно указать его в качестве
 аргумента (пр: ./ftest NNPNumberRangeFindTest)

Для многих functional тестов нужен запущенный биллер. Например для NNPNumberRangeFIndTest
нужен 99-ый биллер

Comparative тесты
Сравнительные тесты работают на питоне.

sampler.py - генерирует тестовые звонки, которые потом проверяются billing.py и voip_routing.py

auth_caller.py - запускает тесты, результаты которых потом проверяются auth_comparer.py

для сравнительных тестов в в базе nispd создается схема tests.

схема работы auth_tests
1) сначала запускается старые версии биллера.
2) запускается auth_caller, и он вызывает для регионов из regions-list
 тесты из auth.test_auth
3) запускается новая версия биллера.
4) запускается auth_caller второй раз, и он вызывает для регионов из regions-list
 тесты из auth.test_auth
5) в рез-те действий (1-4) в tests.auth_tests появляются записи результатов тестирования
 старой и новой версии биллера.
6) запускается auth_comparer который сравнивает эти записи и пытается найти несовпадения.
 Если несовпадения найдены, auth_comparer их выводит.
7) можно запустить tests/comparative/clean_tests.py для очистки бд от рез-ов тестирования
